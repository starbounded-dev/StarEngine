namespace StarEngine
{
	public class Random
	{
		private static ulong[] s_State;

		private const double INCR_DOUBLE = 1.0 / (1UL << 53);
		private const float INCR_FLOAT = 1f / (1U << 24);

		/// <summary>
		/// Initializes the static random number generator state with a fixed seed.
		/// </summary>
		static Random()
		{
			ulong seed = 123456UL;
			s_State = xorshift256_init(seed);
		}

		/// <summary>
		/// Applies the SplitMix64 algorithm to scramble a 64-bit input value, producing a well-distributed 64-bit pseudorandom output.
		/// </summary>
		/// <param name="state">The input value to be scrambled.</param>
		/// <returns>A 64-bit pseudorandom value derived from the input.</returns>
		private static ulong splitmix64(ulong state)
		{
			state += 0x9E3779B97f4A7C15;
			state = (state ^ (state >> 30)) * 0xBF58476D1CE4E5B9;
			state = (state ^ (state >> 27)) * 0x94D049BB133111EB;
			return state ^ (state >> 31);
		}

		/// <summary>
		/// Initializes and returns a four-element state array for the xoshiro256+ pseudorandom number generator using the provided seed.
		/// </summary>
		/// <param name="seed">The initial seed value for state generation.</param>
		/// <returns>An array of four 64-bit unsigned integers representing the PRNG state.</returns>
		private static ulong[] xorshift256_init(ulong seed)
		{
			ulong[] result = new ulong[4];
			result[0] = splitmix64(seed);
			result[1] = splitmix64(result[0]);
			result[2] = splitmix64(result[1]);
			result[3] = splitmix64(result[2]);
			return result;
		}

		/// <summary>
		/// Performs a left bitwise rotation on a 64-bit unsigned integer by the specified number of bits.
		/// </summary>
		/// <param name="x">The value to rotate.</param>
		/// <param name="k">The number of bits to rotate left.</param>
		/// <returns>The result of rotating <paramref name="x"/> left by <paramref name="k"/> bits.</returns>
		private static ulong rol64(ulong x, int k)
		{
			return (x << k) | (x >> (64 - k));
		}

		/// <summary>
		/// Advances the internal PRNG state using the xoshiro256+ algorithm and returns the next 64-bit pseudorandom value.
		/// </summary>
		/// <returns>A 64-bit unsigned integer pseudorandom number.</returns>
		private static ulong xoshiro256p()
		{
			ulong[] state = s_State;

			ulong result = rol64(state[1] * 5, 7) * 9;
			ulong t = state[1] << 17;

			state[2] ^= state[0];
			state[3] ^= state[1];
			state[1] ^= state[2];
			state[0] ^= state[3];

			state[2] ^= t;
			state[3] = rol64(state[3], 45);

			return result;
		}

		/// <summary>
		/// Returns a pseudorandom 64-bit unsigned integer generated by the xoshiro256+ algorithm.
		/// </summary>
		/// <returns>A pseudorandom <see cref="ulong"/> value.</returns>
		public static ulong UInt64()
		{
			return xoshiro256p();
		}

		/// <summary>
		/// Returns a pseudorandom floating-point number in the range [0, 1).
		/// </summary>
		/// <returns>A float uniformly distributed between 0 (inclusive) and 1 (exclusive).</returns>
		public static float Float()
		{
			return (UInt64() >> 40) * INCR_FLOAT;
		}

		/// <summary>
		/// Returns a Vector3 with each component set to a random float in the range [0, 1).
		/// </summary>
		/// <returns>A Vector3 with pseudorandom float components between 0 (inclusive) and 1 (exclusive).</returns>
		public static Vector3 Vec3()
		{
			return new Vector3(Float(), Float(), Float());
		}

		/// <summary>
		/// Returns a pseudorandom double in the range [0, 1).
		/// </summary>
		/// <returns>A double-precision floating-point number uniformly distributed in [0, 1).</returns>
		public static double Double()
		{
			return (UInt64() >> 11) * INCR_DOUBLE;
		}

		/// <summary>
		/// Returns either +1.0f or -1.0f with equal probability.
		/// </summary>
		public static float SignF()
		{
			return UInt64() % 2 == 0 ? 1.0f : -1.0f;
		}

		/// <summary>
		/// Returns a pseudorandom float within the specified range [minValue, maxValue).
		/// </summary>
		/// <param name="minValue">The inclusive lower bound of the range.</param>
		/// <param name="maxValue">The exclusive upper bound of the range.</param>
		/// <returns>A pseudorandom float greater than or equal to minValue and less than maxValue.</returns>
		public static float Range(float minValue, float maxValue)
		{
			return Float() * (maxValue - minValue) + minValue;
		}

		/// <summary>
		/// Returns a pseudorandom integer greater than or equal to <paramref name="minValue"/> and less than <paramref name="maxValue"/>.
		/// </summary>
		/// <param name="minValue">The inclusive lower bound of the random number returned.</param>
		/// <param name="maxValue">The exclusive upper bound of the random number returned.</param>
		/// <returns>A pseudorandom integer in the range [minValue, maxValue).</returns>
		public static int Range(int minValue, int maxValue)
		{
			return ((int)(UInt64() >> 33) % (maxValue - minValue)) + minValue;
		}
	}
}
